//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
/**
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.


Abstract:
	Windows CE Bluetooth stack layer sample

**/
#include <windows.h>
#include <winerror.h>
#include <bthapi.h>
#include <bthutil.h>

#include <svsutil.hxx>
#include <winsock2.h>
#include <winsock.h>
#include <ws2bth.h>
#include <service.h>
#include <imm.h>


#include "mobileremoteapi.hxx"
#include "hid.h"
#include "../l2capdev/mobileremotedrv.hxx"

extern "C" const BOOL g_fl2capApiCOM;

HANDLE hDev = INVALID_HANDLE_VALUE;

extern "C" void UnregisterServices(BT_ADDR *pba)
{
    SOCKADDR_BTH sa;
	memset (&sa, 0, sizeof(sa));

	*(BT_ADDR *)(&sa.btAddr) = *pba;
	sa.addressFamily = AF_BT;

	CSADDR_INFO		csai;

	memset (&csai, 0, sizeof(csai));
	csai.RemoteAddr.lpSockaddr = (sockaddr *)&sa;
	csai.RemoteAddr.iSockaddrLength = sizeof(sa);

	WSAQUERYSET		wsaq;
	memset (&wsaq, 0, sizeof(wsaq));
	wsaq.dwSize      = sizeof(wsaq);
	wsaq.dwNameSpace = NS_BTH;
	wsaq.lpBlob      = NULL;
	wsaq.lpcsaBuffer = &csai;

	HANDLE hLookup;
	int iRet = WSALookupServiceBegin (&wsaq, 0, &hLookup);

	while (ERROR_SUCCESS == iRet) {
		union {
			CHAR buf[5000];
			double __unused;
		};

		LPWSAQUERYSET pwsaResults = (LPWSAQUERYSET) buf;
		DWORD dwSize  = sizeof(buf);

		memset(pwsaResults, 0, sizeof(WSAQUERYSET));
		pwsaResults->dwSize      = sizeof(WSAQUERYSET);
		pwsaResults->dwNameSpace = NS_BTH;
		pwsaResults->lpBlob      = NULL;

		iRet = WSALookupServiceNext (hLookup, 0, &dwSize, pwsaResults);

		if (iRet == SOCKET_ERROR)
        {
			Sleep(0);
        }
        else
        {
            //
        }
	}
	WSALookupServiceEnd(hLookup);
}

int Initialize (void) {
	if (hDev != INVALID_HANDLE_VALUE)
		return TRUE;

	hDev = CreateFile (L"L2C1:", GENERIC_READ | GENERIC_WRITE,
									FILE_SHARE_READ | FILE_SHARE_WRITE,
									NULL, OPEN_EXISTING, 0, NULL);

	return (hDev != INVALID_HANDLE_VALUE) ? TRUE : FALSE;
}

extern "C" int L2CAPLoad (void)
{
	HANDLE hDevice = ActivateDevice(L"Drivers\\BuiltIn\\l2cap", NULL);
	if (hDevice) {
		HKEY hk;
        DWORD    dwDisp;
		if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Bluetooth", 0, 0, 0, KEY_ALL_ACCESS, 0, &hk, &dwDisp)) {
			RegSetValueEx (hk, L"mobileremotedrv_handle", 0, REG_DWORD, (LPBYTE)&hDevice, sizeof(hDevice));
			RegCloseKey (hk);
		}
	}
	else
	{
		L2CAPUnload();
	}
	
	return hDevice != NULL ? ERROR_SUCCESS : ERROR_SERVICE_NOT_ACTIVE;
}

extern "C" int L2CAPUnload (void) {
	HKEY hk;
    DWORD    dwDisp;
	int iRes = FALSE;

	if (hDev != INVALID_HANDLE_VALUE) {
		CloseHandle (hDev);
		hDev = INVALID_HANDLE_VALUE;
	}

	if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Bluetooth", 0, 0, 0, KEY_ALL_ACCESS, 0, &hk, &dwDisp)) {
		HANDLE hDevice = NULL;
		DWORD dwSize = sizeof (hDevice);
		DWORD dwType;

		if ((ERROR_SUCCESS == RegQueryValueEx (hk, L"mobileremotedrv_handle", NULL, &dwType, (LPBYTE)&hDevice, &dwSize)) &&
			(dwType == REG_DWORD) && (dwSize == sizeof (hDevice)) && hDevice) {
			RegDeleteValue (hk, L"mobileremotedrv_handle");
			DeactivateDevice(hDevice);

			iRes = TRUE;
		}

		RegCloseKey (hk);
	}

	return iRes ? ERROR_SUCCESS : ERROR_SERVICE_NOT_ACTIVE;
}

extern "C" int L2CAPConnect
(
BT_ADDR			*pba,		// =>
unsigned short	usPSM,		// =>
unsigned short	usInMTU,	// =>
unsigned short	*pCID,		// <=
unsigned short	*pusOutMTU	// <=
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));

	bc.L2CAPConnect_p.ba = *pba;
	bc.L2CAPConnect_p.usPSM = usPSM;
	bc.L2CAPConnect_p.usInMTU = usInMTU;

	int iErr = DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPConnect, &bc, sizeof(bc), NULL, NULL, NULL, NULL);

	if (iErr) {
		*pCID = bc.L2CAPConnect_p.usCID;
		*pusOutMTU = bc.L2CAPConnect_p.usOutMTU;
		return ERROR_SUCCESS;
	}

	return GetLastError();
}

extern "C" int L2CAPListen
(
unsigned short	usPSM,		// =>
unsigned short	usInMTU	// =>
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));
	bc.L2CAPListen_p.usPSM = usPSM;
	bc.L2CAPListen_p.usInMTU = usInMTU;
	return ((DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPListen, &bc, sizeof(bc), NULL, NULL, NULL, NULL)) ? ERROR_SUCCESS : GetLastError());
}

extern "C" int L2CAPAccept
(
unsigned short	usPSM,		// =>
BT_ADDR			*pba,		// <=
unsigned short	*pusCID,	// <=
unsigned short	*pusOutMTU	// <=
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));

	bc.L2CAPAccept_p.usPSM = usPSM;

	int iErr = DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPAccept, &bc, sizeof(bc), NULL, NULL, NULL, NULL);
	if (iErr) {
		*pba = bc.L2CAPAccept_p.ba;
		*pusCID = bc.L2CAPAccept_p.usCID;
		*pusOutMTU = bc.L2CAPAccept_p.usOutMTU;
		return ERROR_SUCCESS;
	}

	return GetLastError();
}

extern "C" int L2CAPWrite
(
unsigned short	cid,
unsigned int	cBuffer,
unsigned char	*pBuffer
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));

	bc.L2CAPReadWrite_p.cBuffer = cBuffer;
	bc.L2CAPReadWrite_p.usCID   = cid;
	bc.L2CAPReadWrite_p.pBuffer = pBuffer;

	return ((DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPWrite, &bc, sizeof(bc), NULL, NULL, NULL, NULL)) ? ERROR_SUCCESS : GetLastError());
}


extern "C" int L2CAPRead
(
unsigned short	cid,
unsigned int	cBuffer,
unsigned int	*pRequired,
unsigned char	*pBuffer
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));

	bc.L2CAPReadWrite_p.cBuffer = cBuffer;
	bc.L2CAPReadWrite_p.usCID   = cid;
	bc.L2CAPReadWrite_p.pBuffer = pBuffer;

	int iErr = DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPRead, &bc, sizeof(bc), NULL, NULL, NULL, NULL);
	*pRequired = bc.L2CAPReadWrite_p.cRequired;
	return ((iErr) ? ERROR_SUCCESS : GetLastError());
}


extern "C" int L2CAPCloseCID
(
unsigned short cid
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));

	bc.L2CAPClose_p.us = cid;

	return ((DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPCloseCID, &bc, sizeof(bc), NULL, NULL, NULL, NULL)) ? ERROR_SUCCESS : GetLastError());
}

extern "C" int L2CAPClosePSM
(
unsigned short psm
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));

	bc.L2CAPClose_p.us = psm;

	return ((DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPClosePSM, &bc, sizeof(bc), NULL, NULL, NULL, NULL)) ? ERROR_SUCCESS : GetLastError());
}

extern "C" int L2CAPPing
(
BT_ADDR	*pbt,
unsigned int cBufferIn,
unsigned char *pBufferIn,
unsigned int *pcBufferOut,
unsigned char *pBufferOut
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));

	bc.L2CAPPing_p.ba = *pbt;
	bc.L2CAPPing_p.cBufferIn = cBufferIn;
	bc.L2CAPPing_p.cBufferOut = *pcBufferOut;
	bc.L2CAPPing_p.pBufferIn = pBufferIn;
	bc.L2CAPPing_p.pBufferOut = pBufferOut;

	int iRes = ((DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPPing, &bc, sizeof(bc), NULL, NULL, NULL, NULL)) ? ERROR_SUCCESS : GetLastError());
	if (iRes == ERROR_SUCCESS)
		*pcBufferOut = bc.L2CAPPing_p.cBufferOut;
	else
		*pcBufferOut = 0;

	return iRes;
}

extern "C" int L2CAPConfigReq
(
unsigned short usCID,
unsigned short usInMTU,
unsigned short usOutFlushTO,
struct btFLOWSPEC *pOutFlow,
int cOptNum,
struct btCONFIGEXTENSION **ppExtendedOptions
) {
	if (! Initialize())
		return ERROR_SERVICE_NOT_ACTIVE;

	L2CAPDEVAPICALL bc;
	memset (&bc, 0, sizeof(bc));

	bc.L2CAPConfigReq_p.usCID = usCID;
	bc.L2CAPConfigReq_p.usInMTU = usInMTU;
	bc.L2CAPConfigReq_p.usOutFlushTO = usOutFlushTO;
	bc.L2CAPConfigReq_p.pOutFlow = pOutFlow;
	bc.L2CAPConfigReq_p.cOptNum = cOptNum;
	bc.L2CAPConfigReq_p.ppExtendedOptions = ppExtendedOptions;

	int iRes = ((DeviceIoControl (hDev, L2CAPDEV_IOCTL_L2CAPConfigReq, &bc, sizeof(bc), NULL, NULL, NULL, NULL)) ? ERROR_SUCCESS : GetLastError());
	
	return iRes;
}


extern "C" int SDPCleanup()
{
	return ::WSACleanup();
}

extern "C" int SDPRegister()
{
	SOCKET socket = NULL;
	WORD wVersionRequested = 0x202;
	WSADATA wsData;
	SOCKADDR_BTH sab;

	if (0 == ::WSAStartup(wVersionRequested, &wsData))
	{
		socket = ::socket(AF_BTH, SOCK_STREAM, BTHPROTO_RFCOMM); 
	}
	const int cSdpRecord = 0x0000022b;
	BYTE rgbSdpRecord[] = {
		0x36, 0x02, 0x28, 0x09, 0x00, 0x01, 0x35, 0x03, 
		0x19, 0x11, 0x24, 0x09, 0x00, 0x04, 0x35, 0x0d, 
		0x35, 0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x11, 
		0x35, 0x03, 0x19, 0x00, 0x11, 0x09, 0x00, 0x05, 
		0x35, 0x03, 0x19, 0x10, 0x02, 0x09, 0x00, 0x06, 
		0x35, 0x09, 0x09, 0x65, 0x6e, 0x09, 0x00, 0x6a, 
		0x09, 0x01, 0x00, 0x09, 0x00, 0x09, 0x35, 0x08, 
		0x35, 0x06, 0x19, 0x11, 0x24, 0x09, 0x01, 0x00, 
		0x09, 0x00, 0x0d, 0x35, 0x0f, 0x35, 0x0d, 0x35, 
		0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x13, 0x35, 
		0x03, 0x19, 0x00, 0x11, 0x09, 0x01, 0x00, 0x25, 
		0x17, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x53, 
		0x52, 0x43, 0x20, 0x4d, 0x6f, 0x62, 0x69, 0x6c, 
		0x65, 0x20, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 
		0x09, 0x01, 0x01, 0x25, 0x1f, 0x43, 0x6f, 0x6e, 
		0x74, 0x72, 0x6f, 0x6c, 0x20, 0x79, 0x6f, 0x75, 
		0x72, 0x20, 0x50, 0x43, 0x20, 0x66, 0x72, 0x6f, 
		0x6d, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x70, 
		0x68, 0x6f, 0x6e, 0x65, 0x09, 0x01, 0x02, 0x25, 
		0x09, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x53, 
		0x52, 0x43, 0x09, 0x02, 0x00, 0x09, 0x01, 0x00, 
		0x09, 0x02, 0x01, 0x09, 0x01, 0x11, 0x09, 0x02, 
		0x02, 0x08, 0x40, 0x09, 0x02, 0x03, 0x08, 0x33, 
		0x09, 0x02, 0x04, 0x28, 0x01, 0x09, 0x02, 0x05, 
		0x28, 0x01, 0x09, 0x02, 0x06, 0x36, 0x01, 0x40, 
		0x36, 0x01, 0x3d, 0x08, 0x22, 0x26, 0x01, 0x38, 
		0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x85, 0x02, 
		0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 0x01, 
		0x29, 0x08, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 
		0x95, 0x08, 0x81, 0x02, 0x05, 0x01, 0x09, 0x30, 
		0x09, 0x31, 0x16, 0x01, 0xf8, 0x26, 0xff, 0x07, 
		0x75, 0x0c, 0x95, 0x02, 0x81, 0x06, 0x09, 0x38, 
		0x15, 0x81, 0x25, 0x7f, 0x75, 0x08, 0x95, 0x01, 
		0x81, 0x06, 0x05, 0x0c, 0x0a, 0x38, 0x02, 0x81, 
		0x06, 0x05, 0x09, 0x19, 0x09, 0x29, 0x10, 0x15, 
		0x00, 0x25, 0x01, 0x95, 0x08, 0x75, 0x01, 0x81, 
		0x02, 0xc0, 0xc0, 0x05, 0x01, 0x09, 0x06, 0xa1, 
		0x01, 0x85, 0x01, 0x75, 0x01, 0x95, 0x08, 0x05, 
		0x07, 0x19, 0xe0, 0x29, 0xe7, 0x15, 0x00, 0x25, 
		0x01, 0x81, 0x02, 0x95, 0x01, 0x75, 0x08, 0x81, 
		0x03, 0x95, 0x01, 0x75, 0x08, 0x91, 0x03, 0x95, 
		0x06, 0x75, 0x08, 0x15, 0x00, 0x26, 0xff, 0x00, 
		0x05, 0x07, 0x19, 0x00, 0x29, 0xff, 0x81, 0x00, 
		0xc0, 0x05, 0x0c, 0x09, 0x01, 0xa1, 0x01, 0x85, 
		0x03, 0x75, 0x10, 0x95, 0x02, 0x15, 0x01, 0x26, 
		0xff, 0x02, 0x19, 0x01, 0x2a, 0xff, 0x02, 0x81, 
		0x60, 0xc0, 0x05, 0x0c, 0x09, 0x01, 0xa1, 0x01, 
		0x85, 0xac, 0x05, 0x01, 0x09, 0x06, 0xa1, 0x02, 
		0x05, 0x06, 0x09, 0x20, 0x15, 0x00, 0x25, 0xff, 
		0x75, 0x08, 0x95, 0x01, 0x81, 0x02, 0xc0, 0xc0, 
		0x05, 0x01, 0x09, 0x80, 0xa1, 0x01, 0x85, 0x04, 
		0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x01, 
		0x09, 0x82, 0x81, 0x02, 0x95, 0x01, 0x75, 0x07, 
		0x81, 0x03, 0xc0, 0x05, 0x0c, 0x09, 0x01, 0xa1, 
		0x01, 0x85, 0xad, 0x05, 0x01, 0x09, 0x06, 0xa1, 
		0x02, 0x06, 0x00, 0xff, 0x25, 0x01, 0x75, 0x01, 
		0x95, 0x02, 0x0a, 0x03, 0xfe, 0x0a, 0x04, 0xfe, 
		0x81, 0x02, 0x95, 0x06, 0x81, 0x03, 0xc0, 0xc0, 
		0x05, 0x0c, 0x09, 0x01, 0xa1, 0x01, 0x85, 0xff, 
		0x05, 0x06, 0x15, 0x00, 0x25, 0x02, 0x95, 0x01, 
		0x75, 0x02, 0x19, 0x24, 0x29, 0x26, 0x81, 0x40, 
		0x75, 0x06, 0x81, 0x01, 0xc0, 0x06, 0x00, 0xff, 
		0x09, 0x01, 0xa1, 0x01, 0x85, 0x10, 0x75, 0x08, 
		0x95, 0x06, 0x15, 0x00, 0x26, 0xff, 0x00, 0x09, 
		0x01, 0x81, 0x00, 0x09, 0x01, 0x91, 0x00, 0xc0, 
		0x09, 0x02, 0x07, 0x35, 0x08, 0x35, 0x06, 0x09, 
		0x04, 0x09, 0x09, 0x01, 0x00, 0x09, 0x02, 0x0b, 
		0x09, 0x01, 0x00, 0x09, 0x02, 0x0c, 0x09, 0x0c, 
		0x80, 0x09, 0x02, 0x0d, 0x28, 0x00, 0x09, 0x02, 
		0x0e, 0x28, 0x01
	};
	//const int cSdpRecord = 0x00000204;
	//BYTE rgbSdpRecord[] = {
	//	0x36, 0x02, 0x01, 0x09, 0x00, 0x01, 0x35, 0x03, 
	//	0x19, 0x11, 0x24, 0x09, 0x00, 0x04, 0x35, 0x0d, 
	//	0x35, 0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x11, 
	//	0x35, 0x03, 0x19, 0x00, 0x11, 0x09, 0x00, 0x05, 
	//	0x35, 0x03, 0x19, 0x10, 0x02, 0x09, 0x00, 0x06, 
	//	0x35, 0x09, 0x09, 0x65, 0x6e, 0x09, 0x00, 0x6a, 
	//	0x09, 0x01, 0x00, 0x09, 0x00, 0x09, 0x35, 0x08, 
	//	0x35, 0x06, 0x19, 0x11, 0x24, 0x09, 0x01, 0x00, 
	//	0x09, 0x00, 0x0d, 0x35, 0x0f, 0x35, 0x0d, 0x35, 
	//	0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x13, 0x35, 
	//	0x03, 0x19, 0x00, 0x11, 0x09, 0x01, 0x00, 0x25, 
	//	0x08, 0xa8, 0xeb, 0x98, 0x35, 0xf8, 0x16, 0xde, 
	//	0x03, 0x09, 0x01, 0x01, 0x25, 0x08, 0xa8, 0xeb, 
	//	0x98, 0x35, 0xf8, 0x16, 0xde, 0x03, 0x09, 0x01, 
	//	0x02, 0x25, 0x08, 0xa8, 0xeb, 0x98, 0x35, 0xf8, 
	//	0x16, 0xde, 0x03, 0x09, 0x02, 0x00, 0x09, 0x01, 
	//	0x00, 0x09, 0x02, 0x01, 0x09, 0x01, 0x11, 0x09, 
	//	0x02, 0x02, 0x08, 0x40, 0x09, 0x02, 0x03, 0x08, 
	//	0x21, 0x09, 0x02, 0x04, 0x28, 0x01, 0x09, 0x02, 
	//	0x05, 0x28, 0x01, 0x09, 0x02, 0x06, 0x36, 0x01, 
	//	0x40, 0x36, 0x01, 0x3d, 0x08, 0x22, 0x26, 0x01, 
	//	0x38, 0x05, 0x01, 0x09, 0x02, 0xa1, 0x01, 0x85, 
	//	0x02, 0x09, 0x01, 0xa1, 0x00, 0x05, 0x09, 0x19, 
	//	0x01, 0x29, 0x08, 0x15, 0x00, 0x25, 0x01, 0x75, 
	//	0x01, 0x95, 0x08, 0x81, 0x02, 0x05, 0x01, 0x09, 
	//	0x30, 0x09, 0x31, 0x16, 0x01, 0xf8, 0x26, 0xff, 
	//	0x07, 0x75, 0x0c, 0x95, 0x02, 0x81, 0x06, 0x09, 
	//	0x38, 0x15, 0x81, 0x25, 0x7f, 0x75, 0x08, 0x95, 
	//	0x01, 0x81, 0x06, 0x05, 0x0c, 0x0a, 0x38, 0x02, 
	//	0x81, 0x06, 0x05, 0x09, 0x19, 0x09, 0x29, 0x10, 
	//	0x15, 0x00, 0x25, 0x01, 0x95, 0x08, 0x75, 0x01, 
	//	0x81, 0x02, 0xc0, 0xc0, 0x05, 0x01, 0x09, 0x06, 
	//	0xa1, 0x01, 0x85, 0x01, 0x75, 0x01, 0x95, 0x08, 
	//	0x05, 0x07, 0x19, 0xe0, 0x29, 0xe7, 0x15, 0x00, 
	//	0x25, 0x01, 0x81, 0x02, 0x95, 0x01, 0x75, 0x08, 
	//	0x81, 0x03, 0x95, 0x01, 0x75, 0x08, 0x91, 0x03, 
	//	0x95, 0x06, 0x75, 0x08, 0x15, 0x00, 0x26, 0xff, 
	//	0x00, 0x05, 0x07, 0x19, 0x00, 0x29, 0xff, 0x81, 
	//	0x00, 0xc0, 0x05, 0x0c, 0x09, 0x01, 0xa1, 0x01, 
	//	0x85, 0x03, 0x75, 0x10, 0x95, 0x02, 0x15, 0x01, 
	//	0x26, 0xff, 0x02, 0x19, 0x01, 0x2a, 0xff, 0x02, 
	//	0x81, 0x60, 0xc0, 0x05, 0x0c, 0x09, 0x01, 0xa1, 
	//	0x01, 0x85, 0xac, 0x05, 0x01, 0x09, 0x06, 0xa1, 
	//	0x02, 0x05, 0x06, 0x09, 0x20, 0x15, 0x00, 0x25, 
	//	0xff, 0x75, 0x08, 0x95, 0x01, 0x81, 0x02, 0xc0, 
	//	0xc0, 0x05, 0x01, 0x09, 0x80, 0xa1, 0x01, 0x85, 
	//	0x04, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 
	//	0x01, 0x09, 0x82, 0x81, 0x02, 0x95, 0x01, 0x75, 
	//	0x07, 0x81, 0x03, 0xc0, 0x05, 0x0c, 0x09, 0x01, 
	//	0xa1, 0x01, 0x85, 0xad, 0x05, 0x01, 0x09, 0x06, 
	//	0xa1, 0x02, 0x06, 0x00, 0xff, 0x25, 0x01, 0x75, 
	//	0x01, 0x95, 0x02, 0x0a, 0x03, 0xfe, 0x0a, 0x04, 
	//	0xfe, 0x81, 0x02, 0x95, 0x06, 0x81, 0x03, 0xc0, 
	//	0xc0, 0x05, 0x0c, 0x09, 0x01, 0xa1, 0x01, 0x85, 
	//	0xff, 0x05, 0x06, 0x15, 0x00, 0x25, 0x02, 0x95, 
	//	0x01, 0x75, 0x02, 0x19, 0x24, 0x29, 0x26, 0x81, 
	//	0x40, 0x75, 0x06, 0x81, 0x01, 0xc0, 0x06, 0x00, 
	//	0xff, 0x09, 0x01, 0xa1, 0x01, 0x85, 0x10, 0x75, 
	//	0x08, 0x95, 0x06, 0x15, 0x00, 0x26, 0xff, 0x00, 
	//	0x09, 0x01, 0x81, 0x00, 0x09, 0x01, 0x91, 0x00, 
	//	0xc0, 0x09, 0x02, 0x07, 0x35, 0x08, 0x35, 0x06, 
	//	0x09, 0x04, 0x09, 0x09, 0x01, 0x00, 0x09, 0x02, 
	//	0x0b, 0x09, 0x01, 0x00, 0x09, 0x02, 0x0c, 0x09, 
	//	0x0c, 0x80, 0x09, 0x02, 0x0d, 0x28, 0x00, 0x09, 
	//	0x02, 0x0e, 0x28, 0x01
	//};
	//const int cSdpRecord = 0x00000113;
	//BYTE rgbSdpRecord[] = {
	//	0x36, 0x01, 0x10, 0x09, 0x00, 0x01, 0x35, 0x03, 
	//	0x19, 0x11, 0x24, 0x09, 0x00, 0x04, 0x35, 0x0d, 
	//	0x35, 0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x11, 
	//	0x35, 0x03, 0x19, 0x00, 0x11, 0x09, 0x00, 0x05, 
	//	0x35, 0x03, 0x19, 0x10, 0x02, 0x09, 0x00, 0x06, 
	//	0x35, 0x09, 0x09, 0x65, 0x6e, 0x09, 0x00, 0x6a, 
	//	0x09, 0x01, 0x00, 0x09, 0x00, 0x09, 0x35, 0x08, 
	//	0x35, 0x06, 0x19, 0x11, 0x24, 0x09, 0x01, 0x00, 
	//	0x09, 0x00, 0x0d, 0x35, 0x0f, 0x35, 0x0d, 0x35, 
	//	0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x13, 0x35, 
	//	0x03, 0x19, 0x00, 0x11, 0x09, 0x01, 0x00, 0x25, 
	//	0x00, 0x09, 0x01, 0x01, 0x25, 0x00, 0x09, 0x01, 
	//	0x02, 0x25, 0x00, 0x09, 0x02, 0x00, 0x09, 0x01, 
	//	0x00, 0x09, 0x02, 0x01, 0x09, 0x01, 0x11, 0x09, 
	//	0x02, 0x02, 0x08, 0xc0, 0x09, 0x02, 0x03, 0x08, 
	//	0x33, 0x09, 0x02, 0x04, 0x28, 0x01, 0x09, 0x02, 
	//	0x05, 0x28, 0x01, 0x09, 0x02, 0x06, 0x35, 0x59, 
	//	0x35, 0x57, 0x08, 0x22, 0x25, 0x53, 0x05, 0x01, 
	//	0x09, 0x02, 0xa1, 0x01, 0x85, 0x02, 0x05, 0x09, 
	//	0x19, 0x01, 0x29, 0x08, 0x15, 0x00, 0x25, 0x01, 
	//	0x75, 0x01, 0x95, 0x08, 0x81, 0x00, 0x05, 0x01, 
	//	0x09, 0x01, 0xa1, 0x00, 0x09, 0x30, 0x09, 0x31, 
	//	0x15, 0x81, 0x25, 0x7f, 0x75, 0x08, 0x95, 0x02, 
	//	0x81, 0x06, 0xc0, 0xc0, 0x05, 0x01, 0x09, 0x06, 
	//	0xa1, 0x01, 0x85, 0x01, 0x05, 0x07, 0x19, 0xe0, 
	//	0x29, 0xe7, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 
	//	0x95, 0x08, 0x81, 0x02, 0x95, 0x01, 0x75, 0x08, 
	//	0x25, 0x65, 0x19, 0x00, 0x29, 0x65, 0x81, 0x00, 
	//	0xc0, 0x09, 0x02, 0x07, 0x35, 0x08, 0x35, 0x06, 
	//	0x09, 0x04, 0x09, 0x09, 0x01, 0x00, 0x09, 0x02, 
	//	0x08, 0x28, 0x00, 0x09, 0x02, 0x09, 0x28, 0x01, 
	//	0x09, 0x02, 0x0a, 0x28, 0x01, 0x09, 0x02, 0x0b, 
	//	0x09, 0x01, 0x00, 0x09, 0x02, 0x0c, 0x09, 0x1f, 
	//	0x40, 0x09, 0x02, 0x0d, 0x28, 0x00, 0x09, 0x02, 
	//	0x0e, 0x28, 0x01
	//};

	//const int cSdpRecord = 0x00000140;
	//BYTE rgbSdpRecord[] = {
	//	0x36, 0x01, 0x3d, 0x09, 0x00, 0x01, 0x35, 0x03, 
	//	0x19, 0x11, 0x24, 0x09, 0x00, 0x04, 0x35, 0x0d, 
	//	0x35, 0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x11, 
	//	0x35, 0x03, 0x19, 0x00, 0x11, 0x09, 0x00, 0x05, 
	//	0x35, 0x03, 0x19, 0x10, 0x02, 0x09, 0x00, 0x06, 
	//	0x35, 0x09, 0x09, 0x65, 0x6e, 0x09, 0x00, 0x6a, 
	//	0x09, 0x01, 0x00, 0x09, 0x00, 0x09, 0x35, 0x08, 
	//	0x35, 0x06, 0x19, 0x11, 0x24, 0x09, 0x01, 0x00, 
	//	0x09, 0x00, 0x0d, 0x35, 0x0f, 0x35, 0x0d, 0x35, 
	//	0x06, 0x19, 0x01, 0x00, 0x09, 0x00, 0x13, 0x35, 
	//	0x03, 0x19, 0x00, 0x11, 0x09, 0x01, 0x00, 0x25, 
	//	0x0f, 0x80, 0xeb, 0x98, 0x37, 0x84, 0xeb, 0x98, 
	//	0x37, 0xd4, 0xeb, 0x98, 0x37, 0x60, 0xbc, 0x30, 
	//	0x09, 0x01, 0x01, 0x25, 0x0f, 0x80, 0xeb, 0x98, 
	//	0x37, 0x84, 0xeb, 0x98, 0x37, 0xd4, 0xeb, 0x98, 
	//	0x37, 0x60, 0xbc, 0x30, 0x09, 0x01, 0x02, 0x25, 
	//	0x0f, 0x80, 0xeb, 0x98, 0x37, 0x84, 0xeb, 0x98, 
	//	0x37, 0xd4, 0xeb, 0x98, 0x37, 0x60, 0xbc, 0x30, 
	//	0x09, 0x02, 0x00, 0x09, 0x01, 0x00, 0x09, 0x02, 
	//	0x01, 0x09, 0x01, 0x11, 0x09, 0x02, 0x02, 0x08, 
	//	0xc0, 0x09, 0x02, 0x03, 0x08, 0x33, 0x09, 0x02, 
	//	0x04, 0x28, 0x01, 0x09, 0x02, 0x05, 0x28, 0x01, 
	//	0x09, 0x02, 0x06, 0x35, 0x59, 0x35, 0x57, 0x08, 
	//	0x22, 0x25, 0x53, 0x05, 0x01, 0x09, 0x02, 0xa1, 
	//	0x01, 0x85, 0x02, 0x05, 0x09, 0x19, 0x01, 0x29, 
	//	0x08, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 
	//	0x08, 0x81, 0x00, 0x05, 0x01, 0x09, 0x01, 0xa1, 
	//	0x00, 0x09, 0x30, 0x09, 0x31, 0x15, 0x81, 0x25, 
	//	0x7f, 0x75, 0x08, 0x95, 0x02, 0x81, 0x06, 0xc0, 
	//	0xc0, 0x05, 0x01, 0x09, 0x06, 0xa1, 0x01, 0x85, 
	//	0x01, 0x05, 0x07, 0x19, 0xe0, 0x29, 0xe7, 0x15, 
	//	0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x08, 0x81, 
	//	0x02, 0x95, 0x01, 0x75, 0x08, 0x25, 0x65, 0x19, 
	//	0x00, 0x29, 0x65, 0x81, 0x00, 0xc0, 0x09, 0x02, 
	//	0x07, 0x35, 0x08, 0x35, 0x06, 0x09, 0x04, 0x09, 
	//	0x09, 0x01, 0x00, 0x09, 0x02, 0x08, 0x28, 0x01, 
	//	0x09, 0x02, 0x09, 0x28, 0x01, 0x09, 0x02, 0x0a, 
	//	0x28, 0x01, 0x09, 0x02, 0x0b, 0x09, 0x01, 0x00, 
	//	0x09, 0x02, 0x0c, 0x09, 0x1f, 0x40, 0x09, 0x02, 
	//	0x0d, 0x28, 0x00, 0x09, 0x02, 0x0e, 0x28, 0x01
	//};

	GUID serviceID = { 0x00001124, 0x0000, 0x1000, { 0x80, 0x00, 0x00, 0x80, 0x5F, 0x9b, 0x34, 0xfb } };
	if (socket)
	{
		memset (&sab, 0, sizeof(sab));

		sab.addressFamily = AF_BTH;
		sab.btAddr = 0;
		sab.serviceClassId = serviceID;
		sab.port = 0;

		DWORD dwError;

		if (0 != (dwError = bind(socket, (SOCKADDR*)&sab, sizeof(sab))))
		{
			dwError = GetLastError();
			closesocket(socket);
			return dwError;
		}
		
		int size = sizeof(SOCKADDR_BTH);
		if (0 != getsockname(socket, (SOCKADDR*)&sab, &size))
		{
			dwError = GetLastError();
			closesocket(socket);
			return dwError;
		}

		WSAQUERYSET service;

		memset(&service, 0, sizeof(WSAQUERYSET));

		struct {
			BTHNS_SETBLOB	b;
			unsigned char   uca[cSdpRecord];
		} bigBlob;

		DWORD dwSize = sizeof(rgbSdpRecord);

		ULONG recordHandle = 0;
		ULONG ulSdpVersion = BTH_SDP_VERSION;
		bigBlob.b.pRecordHandle   = &recordHandle;
		bigBlob.b.pSdpVersion     = &ulSdpVersion;
		bigBlob.b.fSecurity       = 0;
		bigBlob.b.fOptions        = 0;
		bigBlob.b.ulRecordLength  = dwSize;

		memcpy (bigBlob.b.pRecord, rgbSdpRecord, dwSize);

		BLOB blob;
		blob.cbSize    = sizeof(BTHNS_SETBLOB) + dwSize - 1;
		blob.pBlobData = (PBYTE) &bigBlob;

		service.dwSize = sizeof(WSAQUERYSET);
		service.dwNameSpace = NS_BTH;
		service.lpBlob = &blob;
		service.lpszServiceInstanceName = 0;
		service.lpszComment = 0;
		service.dwNumberOfCsAddrs = 0;
		service.lpcsaBuffer = 0;
		service.dwOutputFlags = 0;
		service.lpServiceClassId = 0;

		CSADDR_INFO csAddr;
		memset(&csAddr, 0, sizeof(csAddr));
		csAddr.LocalAddr.iSockaddrLength = sizeof(SOCKADDR_BTH);
		csAddr.LocalAddr.lpSockaddr = (SOCKADDR*)&sab;
		csAddr.iSocketType = SOCK_STREAM;
		csAddr.iProtocol = BTHPROTO_RFCOMM;

		if (0 != (dwError = WSASetService(&service, RNRSERVICE_REGISTER, 0)))
		{
			dwError = WSAGetLastError();
			//printf("%s\n", GetLastErrorMessage(GetLastError()));

			return dwError;
		}

		return S_OK;
	}

	return E_FAIL;
}

extern "C" BOOL BthHidInitialize(BT_ADDR* btReconnect, ushort* usIntrCid, ushort* usIntrMtu, ushort* usCtrlCid, ushort* usCtrlMtu)
{
	BOOL fRet = FALSE;

	return fRet;
}

int state = 0;

DWORD WINAPI ListenThreadCtrl(LPVOID lpVoid)
{
	unsigned short ctrlCid = (unsigned short)lpVoid;

	wprintf (L"Listen thread created for ctrlCid = 0x%04x\n", ctrlCid);

	for (;;)
	{
		unsigned char ucBuffer[1024];
	    int cSize = 0;

		int iErr = L2CAPRead (ctrlCid, sizeof(ucBuffer), (unsigned int *)&cSize, ucBuffer);
		if (iErr != ERROR_SUCCESS)
		{
			wprintf (L"Error 0x%08x (%d)\n", iErr, iErr);
			L2CAPCloseCID (ctrlCid);
			break;
		}

		if (cSize == 1 && ucBuffer[0] == 0x70)
		{
			uchar szBuffer[1];
			szBuffer[0] = 0;

			iErr = L2CAPWrite(ctrlCid, 1, szBuffer);
			Sleep(0);

			state = 1;
		}
		if (cSize == 2 && ucBuffer[0] == 0x90)
		{
			uchar szBuffer[1];
			szBuffer[0] = 0;

			iErr = L2CAPWrite(ctrlCid, 1, szBuffer);
			Sleep(0);

			state = 1;
		}
	}

	wprintf (L"Exiting listening thread for ctrlCid = 0x%04x\n", ctrlCid);
	return 0;
}

unsigned short intrCid = 0;

DWORD WINAPI ListenThreadIntr(LPVOID lpVoid)
{
	unsigned short intrCid = (unsigned short)lpVoid;

	wprintf (L"Listen thread created for intrCid = 0x%04x\n", intrCid);

	for (;;)
	{
		unsigned char ucBuffer[1024];
	    int cSize = 0;

		int iErr = L2CAPRead (intrCid, sizeof(ucBuffer), (unsigned int *)&cSize, ucBuffer);
		if (iErr != ERROR_SUCCESS)
		{
			wprintf (L"Error 0x%08x (%d)\n", iErr, iErr);
			L2CAPCloseCID (intrCid);
			break;
		}
	}

	wprintf (L"Exiting listening thread for intrCid = 0x%04x\n", intrCid);
	return 0;
}
